package tv.hd3g.mvnplugin.setupdb.repos;

import static org.w3c.dom.Node.ELEMENT_NODE;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Date;
import java.util.Optional;
import java.util.function.Consumer;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.apache.maven.plugin.logging.Log;
import org.eclipse.jgit.util.FileUtils;
import org.xml.sax.SAXException;

import tv.hd3g.mvnplugin.setupdb.NodeListIterator;

public class XmlMerge {

	private static final String XML_ATTR_RELATIVE_TO_CHANGELOG_FILE = "relativeToChangelogFile";
	private static final String QUALIFIED_NAME = "databaseChangeLog";
	private static final String NAMESPACE_URI = "http://www.liquibase.org/xml/ns/dbchangelog";
	private static final String SCHEMA_LOCATION = "http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd";

	private final Log log;
	private final Document documentTarget;
	private final Element rootTarget;

	public XmlMerge(final Log log) {
		this.log = log;

		final var df = DocumentBuilderFactory.newInstance();
		df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
		df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
		DocumentBuilder documentBuilder = null;
		try {
			documentBuilder = df.newDocumentBuilder();
		} catch (final Exception e) {
			throw new IllegalStateException("Can't init XML engine", e);
		}
		documentTarget = documentBuilder.newDocument();
		documentTarget.setXmlVersion("1.0");
		documentTarget.setXmlStandalone(true);

		rootTarget = documentTarget.createElementNS(NAMESPACE_URI, QUALIFIED_NAME);
		rootTarget.setAttributeNS("http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", SCHEMA_LOCATION);
		rootTarget.appendChild(documentTarget.createComment("Do not edit!"));
		rootTarget.appendChild(documentTarget.createComment("Automatically generated by " + getClass().getName()
		                                                    + " maven plugin."));
		rootTarget.appendChild(documentTarget.createComment(
		        "This document merge all external and current Liquibase setup dependencies (database-changelog.xml) for this project"));
		rootTarget.appendChild(documentTarget.createComment("Generated the " + new Date().toString()));
	}

	public void save(final File resolvedChangelog) throws IOException {
		if (resolvedChangelog.getParentFile().exists() == false) {
			FileUtils.mkdirs(resolvedChangelog.getParentFile(), true);
		} else if (resolvedChangelog.exists()) {
			FileUtils.delete(resolvedChangelog);
		}
		try (final var outFilePW = new PrintWriter(resolvedChangelog, "UTF-8")) {
			documentTarget.appendChild(rootTarget);
			final var domSource = new DOMSource(documentTarget);
			final var stringwriter = new StringWriter();
			final var streamresult = new StreamResult(stringwriter);
			final var tf = TransformerFactory.newInstance();
			final var transformer = tf.newTransformer();
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			transformer.transform(domSource, streamresult);
			outFilePW.print(stringwriter.toString());
		} catch (final UnsupportedEncodingException uee) {
			throw new IOException("Encoding XML is not supported", uee);
		} catch (final TransformerException tc) {
			throw new IOException("Converting error between XML and String", tc);
		}
	}

	public void addChangelog(final File changelog) {
		checkChangelogFile(changelog);
		final var parentChangelog = changelog.getParent();
		log.debug("Open changelog: " + changelog);

		final Document changelogDocument = openXmlFile(changelog);

		rootTarget.appendChild(documentTarget.createComment("Content of " + changelog.getAbsolutePath()));

		final var nodeList = changelogDocument.getDocumentElement().getChildNodes();

		if (nodeList.getLength() == 0) {
			return;
		}

		log.info("Load " + nodeList.getLength() + " change(s) from Liquibase changelog \"" + changelog + "\"");

		new NodeListIterator(nodeList).stream()
		        .filter(node -> node.getNodeType() == ELEMENT_NODE)
		        .map(node -> (Element) documentTarget.importNode(node, true))
		        .forEach(element -> {
			        getRelativeIncludedfile(parentChangelog, element).ifPresent(relativeIncludedfile -> {
				        element.setAttribute("file", relativeIncludedfile.getPath().replace('\\', '/'));
				        element.removeAttribute(XML_ATTR_RELATIVE_TO_CHANGELOG_FILE);
			        });

			        rootTarget.appendChild(element);
		        });
	}

	public void importChangeLog(final File changelog, final String sourceName) {
		checkChangelogFile(changelog);

		final var parentChangelog = changelog.getParent();
		log.debug("Open changelog: " + changelog);

		final Document changelogDocument = openXmlFile(changelog);
		final var nodeList = changelogDocument.getDocumentElement().getChildNodes();

		if (nodeList.getLength() == 0) {
			return;
		}

		rootTarget.appendChild(documentTarget.createComment("Start the content of " + sourceName));

		log.info("Load " + nodeList.getLength() + " change(s) from Liquibase changelog \"" + changelog
		         + "\" in " + sourceName);

		/**
		 * Recursive call
		 */
		final Consumer<File> externalChangeLogImporter = relativeIncludedfile -> importChangeLog(
		        relativeIncludedfile, sourceName + ", include " + relativeIncludedfile.getName());

		new NodeListIterator(nodeList).stream()
		        .filter(node -> node.getNodeType() == ELEMENT_NODE)
		        .map(node -> (Element) node)
		        .forEach(element -> getRelativeIncludedfile(parentChangelog, element)
		                .ifPresentOrElse(
		                        externalChangeLogImporter,
		                        () -> rootTarget.appendChild(documentTarget.importNode(element, true))));
	}

	private static Optional<File> getRelativeIncludedfile(final String parentChangelog,
	                                                      final Element element) {
		if (element.hasAttribute(XML_ATTR_RELATIVE_TO_CHANGELOG_FILE) == false
		    || "true".equalsIgnoreCase(element.getAttribute(XML_ATTR_RELATIVE_TO_CHANGELOG_FILE)) == false) {
			return Optional.empty();
		}

		final var relativeIncludedfileName = element.getAttribute("file").replace("/", File.separator);
		final var relativeIncludedfile = new File(parentChangelog + File.separator + relativeIncludedfileName);
		if (relativeIncludedfile.exists() == false) {
			throw new IllegalAccessError("Can't found included relative file "
			                             + element.getAttribute("file") + " from " + parentChangelog);
		}
		return Optional.of(relativeIncludedfile);
	}

	private static Document openXmlFile(final File changelog) {
		try {
			final var df = DocumentBuilderFactory.newInstance();
			df.setFeature("http://xml.org/sax/features/external-general-entities", false);
			df.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
			df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
			df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
			final var xmlDocumentBuilder = df.newDocumentBuilder();
			xmlDocumentBuilder.setErrorHandler(null);
			return xmlDocumentBuilder.parse(changelog);
		} catch (final ParserConfigurationException pce) {
			throw new IllegalStateException("DOM parser error", pce);
		} catch (final SAXException se) {
			throw new IllegalStateException("XML Struct error", se);
		} catch (final IOException ioe) {
			throw new IllegalStateException(ioe);
		}
	}

	private static void checkChangelogFile(final File changelog) {
		if (changelog.exists() == false || changelog.canRead() == false) {
			throw new IllegalStateException("Can't found file: \"" + changelog.getPath() + "\"");
		}
	}

}
